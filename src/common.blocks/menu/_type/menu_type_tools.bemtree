block menu, mod type tools{

    content: {
        var data = this.data, //объект, хранящий всю информацию о request, response и.т.д.
            type = this.ctx.type,
            self = this;

        //выбираем все категории для постов определенного типа (в нашем случае это tools)
        var source = leJsPath.find('.' + data.req.prefLocale + '{.type === "' + type + '"}.categories', {});

        //Удаляем дубликаты категорий
        source = leJsPath.removeDublicates(source, function(a, b) {
            return (!self._.isSimple(a) && !self._.isSimple(b)) ?
                a.url === b.url && a.name === b.name : a === b;
        });

        //отфильтровываем категории мультираздельных постов для которых тип категории не совпадает с текущим типом
        source = source.filter(function(item) {
            return !item.type || item.type === type;
        });

        var localizationHash = {},
            orderHash = {},
            urlArr = [],
            itemsHash = {},
            items = [];

        //Для категорий имеющих локализацию, составляем локализационный хэш
        //Собираем в массив все url для категорий
        source.forEach(function(item, index) {
           if(!self._.isSimple(item)) {
               localizationHash[item.url] = item.name;
               orderHash[item.url] = item.order;
               urlArr.push(item.url);
           }else {
               urlArr.push(item);
           }
        });

        //Для составных url получаем дополнительную локализацию
        //для каждой из частей разделенных /
        var lh = {},
            oh = {};

        Object.getOwnPropertyNames(localizationHash).forEach(function(item, index) {
            var urlParts = item.split('/'),
                nameParts = localizationHash[item].split('/'),
                orderParts = orderHash[item] ? orderHash[item].split('/') : [];

            urlParts.forEach(function(item, index) {
                lh[item] = nameParts[index];
                oh[item] = orderParts[index];
            });
        });

        localizationHash = lh;
        orderHash = oh;

        //из плоского списка категорий строим их дерево
        //с локализованными частями для категорий и подкатегорий
        //вложенность идентифицируется по разделителю вида /
        urlArr.forEach(function(item, index) {

            var parts   = item.split('/'),
                pointer = itemsHash;

            parts.forEach(function(part) {
                pointer = (pointer[part] || (pointer[part] = {
                    key: part,
                    id: item,
                    name: localizationHash[part] || part,
                    order: orderHash[part] || 0
                }));
            });
        });

        //Превращаем полученный hash в array
        items = Object.getOwnPropertyNames(itemsHash).map(function(item, index) {
            return itemsHash[item];
        });

        items.sort(function(a, b){
            if(orderHash[a.key] && orderHash[b.key]) {
                return orderHash[a.key] - orderHash[b.key];
            }else {
                return a.key > b.key;
            }
        });

        if(this._.isArray(items)) {
            var i = 0,
                item,
                ctx = this.ctx,
                _extend = this._.extend;

            this.buf = [];

            //рекурсивно строим меню
            //применяем шаблоны к элементу item текущего блока
            //с модификатором соотвествующим полю мета-информации
            //значения которого отображаются в меню и идентификацией
            //текущего значения для выделения активного пункта меню
            items.forEach(function(item, index){
                apply('drawMenuItem', this.ctx = _extend(ctx, { item : item, orderHash: orderHash }));
            });

            return this.buf;
        }
    }

    drawMenuItem: {
        var item = this.ctx.item,
            type = this.ctx.type,
            orderHash = this.ctx.orderHash,
            isComplex = apply('complex');

        this.buf.push(apply(
            this._mode = '',
            this.ctx = {
                elem: 'item',
                elemMods: {
                    type : 'categories',
                    complex: isComplex ? 'yes' : '',
                    active : apply('active'),
                    disable : apply('disable')
                },
                url: !isComplex ? '/' + type + '/' + item.id : null,
                name: isComplex ? item.name.toUpperCase() : item.name
            }
        ));

        if(isComplex) {
            var ctx = this.ctx,
                _extend = this._.extend;
            Object.getOwnPropertyNames(item).filter(function(key) {
                 return ['id', 'name', 'key', 'order'].indexOf(key) < 0;
            })
            .sort(function(a, b) {
                if(orderHash[a] && orderHash[b]) {
                    return orderHash[a] - orderHash[b];
                }else {
                    return a > b;
                }
            })
            .forEach(function(key) {
                 apply('drawMenuItem', this.ctx = _extend(ctx, { item : item[key] }));
            });
        }
    }

    complex: {
        return Object.getOwnPropertyNames(this.ctx.item).filter(function(item) {
            return ['id', 'name', 'key', 'order'].indexOf(item) < 0
        }).length > 0
    }

    //определение активного пункта меню и установка значения модификатора active
    active: {
        return this.data.req._parsedUrl.pathname.indexOf(this.ctx.item.id) !== -1 ? 'yes' : '';
    }

    disable: {
        var path = this.data.req._parsedUrl.pathname,
            id = this.ctx.item.id;
        return path.indexOf(id, path.length - id.length) !== -1 ? 'yes' : '';
    }
}
