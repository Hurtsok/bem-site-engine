block menu, mod type libs {

    content: {
        var data = this.data, //объект, хранящий всю информацию о request, response и.т.д.
            config = this.ctx.config,
            self = this;

        var source = this.modules.leJspath.find('.' + data.req.prefLocale + '{.type === $type}.categories', { type : this.ctx.type });

        //  console.debug(source);

        //Удаляем дубликаты категорий
        source = this.modules.leJspath.removeDublicates(source, function(a, b) {
            return (!self._.isSimple(a) && !self._.isSimple(b)) ?
                a.url === b.url && a.name === b.name : a === b;
        });

        source = source.filter(function(item) {
            return !item.type || item.type === self.ctx.type;
        });

        var localizationHash = {},
            urlArr = [],
            itemsHash = {},
            items = [];

        //Для категорий имеющих локализацию, составляем локализационный хэш
        //Собираем в массив все url для категорий
        source.forEach(function(item, index) {
           if(!self._.isSimple(item)) {
               localizationHash[item.url] = item.name;
               urlArr.push(item.url);
           }else {
               urlArr.push(item);
           }
        });

        //Для составных url получаем дополнительную локализацию
        //для каждой из частей разделенных /
        var t = {};
        Object.getOwnPropertyNames(localizationHash).forEach(function(item, index) {
            var urlParts = item.split('/');
            var nameParts = localizationHash[item].split('/');
            urlParts.forEach(function(item, index) {
                t[item] = nameParts[index];
            });
        });

        localizationHash = t;

        var MAX_DEPTH = 2;

        //из плоского списка категорий строим их дерево
        //с локализованными частями для категорий и подкатегорий
        //вложенность идентифицируется по разделителю вида /
        urlArr.forEach(function(item, index) {

            var parts   = item.split('/'),
                pointer = itemsHash,
                id = '';

            parts.forEach(function(item, index) {
                if(index < MAX_DEPTH) {
                    if(index > 0)
                        id += '/';
                    id += item;
                }
            });

            parts.forEach(function(part, index) {
                if(index < MAX_DEPTH) {
                    pointer = (pointer[part] ||
                        (pointer[part] = {
                            key: part,
                            id: id,
                            name: localizationHash[part] || part
                        })
                    );
                }
            });
        });

        //Превращаем полученный hash в array
        Object.getOwnPropertyNames(itemsHash).forEach(function(item, index) {
            items.push(itemsHash[item]);
        });

        //сортируем массив с элементами меню в алфавитном порядке
        items.sort(function(a, b){
            return a.key > b.key;
        });

        if(this._.isArray(items)) {

            var ctx = this.ctx,
                _extend = this._.extend;

            this.buf = [];

            items.forEach(function(item, index){
                apply('drawMenuItem', this.ctx = _extend(ctx, { item : item }));
            });

            return this.buf;
        }

        return [];
    }

    drawMenuItem: {
        var item = this.ctx.item,
            type = this.ctx.type,
            isComplex = apply('complex');

        //функция сортировки версий библиотек в порядке от новых к старым
        var sortF = function(a, b) {
            if(a < b) {
                return 1;
            }else if(a > b) {
                return -1;
            }else {
                return 0;
            };
        };

        this.buf.push(apply(
            this._mode = '',
            this.ctx = {
                elem: 'item',
                elemMods: {
                    type : 'libs',
                    complex: isComplex ? 'yes' : '',
                    active : apply('active'),
                    disable : apply('disable')
                },
                url:  isComplex ? null : '/' + type + '/' + item.id,
                name: isComplex ? item.name.toUpperCase() : item.name
            }
        ));

        //Если пункт меню комплексный (название библиотеки)
        //то дорисовываем пункты меню с версиями библиотеки отсортированные в порядке убывания версии
        if(isComplex) {
            var ctx = this.ctx,
                _extend = this._.extend;

            Object.getOwnPropertyNames(item).filter(function(key) {
                 return ['id', 'name', 'key'].indexOf(key) < 0;
            }).sort(sortF).forEach(function(key) {
                 apply('drawMenuItem', this.ctx = _extend(ctx, { item : item[key] }));
            });
        }
    }

    //определение группирующего пункта меню по наличию ключей
    //дочерних пунктов меню
    complex: {
        return Object.getOwnPropertyNames(this.ctx.item).filter(function(item) {
            return ['id', 'name', 'key'].indexOf(item) < 0
        }).length > 0
    }

    //определение активного пункта меню и установка значения модификатора active
    //по условию если url содержит id текущего пункта меню
    active: {
        return this.data.req._parsedUrl.pathname.indexOf(this.ctx.item.id) !== -1 ? 'yes' : '';
    }

    //определение отключенного пункта меню, если текущий пункт меню активен и не выбран
    //пункт из другого меню, т.е. url заканчивается на id текущего пункта меню
    disable: {
        var path = this.data.req._parsedUrl.pathname,
            id = this.ctx.item.id;
        return path.indexOf(id, path.length - id.length) !== -1 ? 'yes' : '';
    }

}
