 block posts {

    default: {
        return applyNext(
            this._datasrc = this.data.params);
    }

    content: {
        var data = this.data;

        return this.doAsync(
                leDatasrc.loadData.bind(leDatasrc, {})
            )
            .then(
                function(result) {
                    return
                        apply('processData',
                            this.ctx = {
                                data : data,
                                content : result
                            }
                        );
                },
                function(err) {
                    return apply('error', this.ctx = err);
                },
                this
            );
    }

    processData: {
        var DEFAULT_LIMIT = 10;

        var content = this.ctx.content,
            data = this.ctx.data,
            lang = data.params.lang || 'en',
            type = data.params.type || data.page;

        leJspath.stringify(data);

        content = leJspath.filter('.' + lang + '{.type === $type}', content,  { type : type });

        content = apply('sort', this.ctx = {
            content : content,
            data : data
        });

        var total = content.length;

        content = apply('paginate', this.ctx = {
            content : content,
            data : data,
            defaultLimit : DEFAULT_LIMIT
        });

        return [
            apply(
                this._mode = '',
                this.ctx = {
                    elem : 'list',
                    params: {
                        lang : lang,
                        type : type
                    },
                    content : content
                }
            ),
            apply(
                this._mode = '',
                this.ctx = {
                    elem : 'footer',
                    params : {
                        total : total,
                        path  : data.req.path,
                        query : data.req.query,
                        defaultLimit : DEFAULT_LIMIT
                    }
                }
            )
        ];
    }

    sort: {
        var array = this.ctx.content,
            data = this.ctx.data,
            query = data.req.query,
            sort = query.sort,
            config = [];

        if(!sort || sort.length == 0)
            return array;

        sort = sort.substring(1, sort.length - 1).split(', ');

        for(var i = 0; i < sort.length; i++) {
            var condition = sort[i].split(' ');
            config.push({field : condition[0], direction : (condition[1] || 'asc') })
        }

        function compare(a, b, config, index) {
            index = index || 0;
            if(!config[index])
               return 0;

            var field = config[index]['field'],
                desc = config[index]['direction'] === 'desc';

            if(a[field] > b[field]) {
                return desc ? -1 : 1;
            } else if(a[field] < b[field]) {
                return desc ? 1 : -1;
            } else {
                return compare(a, b, config, ++index);
            }
        }

        return array.sort(function(a, b) {
            return compare(a, b, config);
        });
    }

    paginate: {
        var array = this.ctx.content,
            data = this.ctx.data,
            query = data.req.query,
            page = query.page,
            limit = query.limit;

        page = (page && !isNaN(parseFloat(page)) && isFinite(page)) ? page : 1;
        limit = (limit && !isNaN(parseFloat(limit)) && isFinite(limit)) ? limit : this.ctx.defaultLimit;

        return page * limit  <= array.length ?
                array.slice((page - 1) * limit, page * limit) :
                array.slice((page - 1) * limit);
    }
}
