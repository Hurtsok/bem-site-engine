block menu, mod type categories{

    content: {
        var data = this.data, //объект, хранящий всю информацию о request, response и.т.д.
            source = data.source, //содержимое модели (файл data.json)
            type = this.ctx.type,
            self = this;

        var orderHash = {
            'bem': 0,
            'languages': 1,
            'parsers': 2,
            'builders': 3,
            'optimizers': 4
        };

        source = leJspath.find('.' + data.lang + '{.type === "' + type + '"}.categories', source, {});

        //Удаляем дубликаты категорий
        source = leJspath.removeDublicates(source, function(a, b) {
            return (!self._.isSimple(a) && !self._.isSimple(b)) ?
                a.url === b.url && a.name === b.name : a === b;
        });

        var localizationHash = {},
            urlArr = [],
            itemsHash = {},
            items = [];

        //Для категорий имеющих локализацию, составляем локализационный хэш
        //Собираем в массив все url для категорий
        source.forEach(function(item, index) {
           if(!self._.isSimple(item)) {
               localizationHash[item['url']] = item['name'];
               urlArr.push(item['url']);
           }else {
               urlArr.push(item);
           }
        });

        //Для составных url получаем дополнительную локализацию
        //для каждой из частей разделенных /
        var t = {};
        Object.getOwnPropertyNames(localizationHash).forEach(function(item, index) {
            var urlParts = item.split('/');
            var nameParts = localizationHash[item].split('/');
            urlParts.forEach(function(item, index) {
                t[item] = nameParts[index];
            });
        });

        localizationHash = t;

        //из плоского списка категорий строим их дерево
        //с локализованными частями для категорий и подкатегорий
        //вложенность идентифицируется по разделителю вида /
        urlArr.forEach(function(item, index) {

            var parts   = item.split('/'),
                pointer = itemsHash;

            parts.forEach(function(part) {
                pointer = (pointer[part] || (pointer[part] = {key: part, id: item, name: localizationHash[part] || part }));
            });
        });

        leJspath.stringify(itemsHash);

        //Превращаем полученный hash в array
        Object.getOwnPropertyNames(itemsHash).forEach(function(item, index) {
            items.push(itemsHash[item]);
        });


        //сортируем массив с элементами меню так, чтобы простые элементы отображались сверху
        //а имеющие вложенность снизу
        items.sort(function(a, b){
            // if(a.items && b.items) {
            //     return a.items.length > b.items.length;
            // }else if(a.items && !b.items) {
            //     return 1;
            // }else if(!a.items && b.items) {
            //     return -1;
            // }else
            if(orderHash[a.key] && orderHash[b.key]) {
                return orderHash[a.key] - orderHash[b.key];
            }else {
                return a.key > b.key;
            }
        });


        //leJspath.stringify(items);

        // items.sort(function(a, b) {
        //     return a.name > b.name;
        // });

        if(this._.isArray(items)) {
            var i = 0,
                item;

            this.buf = [];

            //при наличии соответсвующего модификатора добавляем
            //пункт меню при нажатии по которому показываются все посты
            //apply('drawAllItem');

            //рекурсивно строим меню
            //применяем шаблоны к элементу item текущего блока
            //с модификатором соотвествующим полю мета-информации
            //значения которого отображаются в меню и идентификацией
            //текущего значения для выделения активного пункта меню
            items.forEach(function(item, index){
                apply('drawMenuItem', this.ctx = this._.extend(this.ctx, { item : item }));
            });

            return this.buf;
        }
    }

    drawAllItem: {
        if(this.mods['all'] === 'yes') {
            this.buf.push(apply(
                this._mode = '',
                this.ctx = {
                    elem: 'item',
                    elemMods: {
                        type : 'categories',
                        active : !this.ctx.id ? 'yes' : ''
                    },
                    url: '/' + this.ctx.type,
                    name: BEM.I18N('menu', 'all-' + this.ctx.type)
                }
            ));
        }
    }

    drawMenuItem: {
        var item = this.ctx.item,
            type = this.ctx.type,
            isComplex = apply('complex');

        this.buf.push(apply(
            this._mode = '',
            this.ctx = {
                elem: 'item',
                elemMods: {
                    type : 'categories',
                    complex: isComplex ? 'yes' : '',
                    active : apply('active')
                },
                url: !isComplex ? '/' + type + '/' + item.id : null,
                name: isComplex ? item.name.toUpperCase() : item.name
            }
        ));

        if(isComplex) {
            Object.getOwnPropertyNames(item).filter(function(key) {
                 return ['id', 'name', 'key'].indexOf(key) < 0;
            }).forEach(function(key) {
                 apply('drawMenuItem', this.ctx = this._.extend(this.ctx, { item : item[key] }));
            });
        }
    }

    complex: {
        return Object.getOwnPropertyNames(this.ctx.item).filter(function(item) {
            return ['id', 'name', 'key'].indexOf(item) < 0
        }).length > 0
    }

    //определение активного пункта меню и установка значения модификатора active
    active: {
        return (this.ctx.id && this.ctx.id === this.ctx.item.id) ? 'yes' : '';
    }
}
