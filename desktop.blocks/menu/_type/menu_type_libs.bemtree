block menu, mod type libs {

    content: {
        var data = this.data, //объект, хранящий всю информацию о request, response и.т.д.
            config = this.ctx.config,
            self = this;

        var source = leJspath.find('.' + data.lang + '{.type === $type}.categories', { type : this.ctx.type });

        //  console.debug(source);

        //Удаляем дубликаты категорий
        source = leJspath.removeDublicates(source, function(a, b) {
            return (!self._.isSimple(a) && !self._.isSimple(b)) ?
                a.url === b.url && a.name === b.name : a === b;
        });

        var localizationHash = {},
            urlArr = [],
            itemsHash = {},
            items = [];

        //Для категорий имеющих локализацию, составляем локализационный хэш
        //Собираем в массив все url для категорий
        source.forEach(function(item, index) {
           if(!self._.isSimple(item)) {
               localizationHash[item.url] = item.name;
               urlArr.push(item.url);
           }else {
               urlArr.push(item);
           }
        });

        //Для составных url получаем дополнительную локализацию
        //для каждой из частей разделенных /
        var t = {};
        Object.getOwnPropertyNames(localizationHash).forEach(function(item, index) {
            var urlParts = item.split('/');
            var nameParts = localizationHash[item].split('/');
            urlParts.forEach(function(item, index) {
                t[item] = nameParts[index];
            });
        });

        localizationHash = t;

        var MAX_DEPTH = 2;

        //из плоского списка категорий строим их дерево
        //с локализованными частями для категорий и подкатегорий
        //вложенность идентифицируется по разделителю вида /
        urlArr.forEach(function(item, index) {

            var parts   = item.split('/'),
                pointer = itemsHash,
                id = '';

            parts.forEach(function(item, index) {
                if(index < MAX_DEPTH) {
                    if(index > 0)
                        id += '/';
                    id += item;
                }
            });

            parts.forEach(function(part, index) {
                if(index < MAX_DEPTH) {
                    pointer = (pointer[part] ||
                        (pointer[part] = {
                            key: part,
                            id: id,
                            name: localizationHash[part] || part
                        })
                    );
                }
            });
        });

        //leJspath.stringify(itemsHash);

        //Превращаем полученный hash в array
        Object.getOwnPropertyNames(itemsHash).forEach(function(item, index) {
            items.push(itemsHash[item]);
        });

        //сортируем массив с элементами меню так, чтобы простые элементы отображались сверху
        //а имеющие вложенность снизу
        items.sort(function(a, b){
            return a.key > b.key;
        });

        if(this._.isArray(items)) {

            this.buf = [];

            items.forEach(function(item, index){
                apply('drawMenuItem', this.ctx = this._.extend(this.ctx, { item : item }));
            });

            return this.buf;
        }

        return [];
    }

    drawMenuItem: {
        var item = this.ctx.item,
            type = this.ctx.type,
            isComplex = apply('complex');

        //функция сортировки версий библиотек в порядке от новых к старым
        var sortF = function(a, b) {
            if(a < b) {
                return 1;
            }else if(a > b) {
                return -1;
            }else {
                return 0;
            };
        };

        this.buf.push(apply(
            this._mode = '',
            this.ctx = {
                elem: 'item',
                elemMods: {
                    type : 'categories',
                    complex: isComplex ? 'yes' : '',
                    active : apply('active')
                },
                url: !isComplex ? '/' + type + '/' + item.id : null,
                name: isComplex ? item.name.toUpperCase() : item.name
            }
        ));

        if(isComplex) {
            Object.getOwnPropertyNames(item).filter(function(key) {
                 return ['id', 'name', 'key'].indexOf(key) < 0;
            }).sort(sortF).forEach(function(key) {
                 apply('drawMenuItem', this.ctx = this._.extend(this.ctx, { item : item[key] }));
            });
        }
    }

    complex: {
        return Object.getOwnPropertyNames(this.ctx.item).filter(function(item) {
            return ['id', 'name', 'key'].indexOf(item) < 0
        }).length > 0
    }

    //определение активного пункта меню и установка значения модификатора active
    active: {
        return (this.ctx.id && this.ctx.id === this.ctx.item.id) ? 'yes' : '';
    }

}
