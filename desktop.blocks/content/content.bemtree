block content {

    default: {
        return applyNext(
            this._datasrc = this.data.params);
    }

    content: {
        return this.doAsync(
                leDatasrc.loadData.bind(leDatasrc, {})
            )
            .then(
                function(result) {
                    return
                        apply('processData',
                            this.ctx = {
                                content : result
                            }
                        );
                },
                function(err) {
                    return apply('error', this.ctx = err);
                },
                this
            );
    }


    /**
     * Если не сработал общий роутинг то возвращаем блок p-{type},
     * в противном случае требуется дополнительное исследование
     */
    processData: {
        return this.data.page !== 'filter' ?
            apply(this._mode = '', this.ctx = { block : 'p-' + this.data.page }) :
            apply('parse-url');
    }

    parse-url: {
        var content = this.ctx.content; //содержимое файла data.json
            data = this.data, //объект хранящий request, response и.т.д
            type = data.params.type, //параметр типа
            url = data.req.url, //строка запроса
            isId = null, //флаг идентификации того, что был запрошен единичный пост
            page = null;

        url = url.split('/').slice(2); //отрезаем /{type}/

        //определяем факт того, что был запрошен единичный пост
        //по попытке поиска поста по типу из url, куску строки запроса
        //идущей после /{type}/ и текущей локали
        isId = leJspath.filter(content, [
                { field: 'type', operand:  '===', value: type },
                { field: 'id', operand:  '===', value: url[0] }
            ], data.lang).length > 0;

        //возвращаем либо блок p-post либо p-{type} для дальнейшего разбора
        page = isId ? 'post' : type;

        return apply(this._mode = '', this.ctx = { block : 'p-' + page, content: content });
    }

}
