block b-page {

    !leJspath.getSource(), default: {
        return this.doAsync(
                leDatasrc.loadData.bind(leDatasrc, {})
            )
            .then(
                function(result) {
                    leJspath.setSource(result); //кеширование данных

                    apply('route');
                    this.ctx.mods = this._.extend({ theme : 'normal', page : this.data.page }, this.ctx.mods);
                    return applyCtx(this.ctx);
                },
                function(err) {
                    return apply('error', this.ctx = err);
                },
                this
            );
    }

    leJspath.getSource(), default: {
        apply('route');
        this.ctx.mods = this._.extend({ theme : 'normal', page : this.data.page }, this.ctx.mods);
        return applyCtx(this.ctx);
    }

    route: {
        //leJspath.stringify(this.data);

        this.data._r = {
            'method':   function() { return apply('method') },
            'libs':     function() { return apply('libs') },
            'articles': function() { return apply('articles') },
            'tools':    function() { return apply('tools') },
            'news':     function() { return apply('news') },
            'authors':  function() { return apply('authors') },
            'tags':     function() { return apply('tags') },
            'index':    function() { return apply('index') }
        };
        return this.data._r[this.data.page].call(this);
    }


    /* ---------------method------------------ */
    method: {
        var data = this.data,
            type = data.page,
            res = leJspath.findCategoryAndIdByUrl(data.req.path, type, data.lang),
            rootId = leJspath.findRootPostId(type, data.lang);

        this.data._q = {
            type: type,
            id: (res && res.id) || rootId,
            category: res && res.category,
            query: {
                predicate: '.' + data.lang + '{.type === $type}{.id !== $rootId}',
                substitution: { type: type, rootId: rootId }
            }
        };

        return apply('createSEO');
    }


    /* ---------------libs------------------ */
    libs: {
        var data = this.data,
            type = data.page,

            lib = data.params['lib'] || null,
            version = data.params['version'] || null,
            category = data.params['category'] || null,
            id = data.params['id'],

            predicate = '.' + data.lang + '{ .type == $type }',
            substitution = { type: type },
            query = null;

        id = leJspath.findIdByTypeAndUrl(type, id || category, data.lang);

        //В случае когда не указана библиотека, т.е. url = /libs,
        //то выбирается первая попавшаяся библиотека
        if(!lib) {
            var categories = leJspath.find('.' + this.data.lang + '{.type === $type}.categories',
                { type : type });

            if(this._.isArray(categories) && categories.length > 0) {
                var url = categories[0].url || categories[0];
                lib = url.split('/')[0];
            }
        }

        predicate += '{.categories ^== $category || .categories.url ^== $category }';
        substitution = this._.extend(substitution, { category: lib });

        //если не указана версия, то выбирается самая новая для данной библиотеки
        if(!version) {
            var versions = [];
            leJspath.find(predicate, substitution).forEach(function(post) {
                post.categories.forEach(function(item){
                    var url = item.url || item;
                    versions.push(url.match(/\d+\.\d+\.\d+/)[0]);
                });
            });

            version = versions.sort().pop();
        }

        substitution = this._.extend(substitution, { category: lib + '/' + version });

        //поиск корневой статьи для библиотеки и показ ее если не указан id другого поста для библиотеки явно
        var rootId = leJspath.find(predicate + '{.root == "true"}.id', substitution);
        rootId = rootId.length > 0 ? rootId[0] : null;

        if(rootId) {
            predicate += '{.id !== $rootId}';
            substitution = this._.extend(substitution, { rootId: rootId });
            id = id || rootId;
        }

        query = { predicate: predicate, substitution: substitution };

        this.data._q = {
            type: type,
            id: id,
            category: category,
            query: query,

            lib: lib,
            version: version
        };

        return apply('createSEO');
    }


    /* --------------articles------------------- */
    articles: {
        var data = this.data,
            type = data.page,
            res = leJspath.findCategoryAndIdByUrl(data.req.path, type, data.lang);

        this.data._q = {
            type: type,
            id: res && res.id,
            category: res && res.category,
            query: {
                predicate: '.' + data.lang + '{.type === $type}',
                substitution: { type: type }
            }
        };

        return apply('createSEO');
    }


    /* ----------------tools----------------- */
    tools: {
        var data = this.data,
            type = data.page,
            res = leJspath.findCategoryAndIdByUrl(data.req.path, type, data.lang),

            id = res && res.id,
            category = res && res.category,
            query = null,
            isOnlyOnePost = false;

        if(category) {
            var predicate = '.' + data.lang + '{.type === $type}' +
                '{.categories === $category || .categories.url === $category}';

            var rootId = leJspath.findRootPostIdByCategory(type, category, data.lang);
            if(rootId) {
                predicate +=  '{.id !== "' + rootId + '"}';
            }

            if(!id && rootId){
                id = rootId;
            }

            query = {
                predicate: predicate,
                substitution: { type: type, category: category }
            };

            //проверка на то, что для данного инструмента есть только один пост
            //если это так, то показываем его в развернутом виде а меню постов прячем
            var source = leJspath.find(query.predicate, query.substitution);
            if(this._.isArray(source) && source.length == 1) {
                isOnlyOnePost = true;
                id = source[0].id;
            }
        }else {
            id = leJspath.findRootPostId(type, data.lang);
            if(!id) {
                query = {
                    predicate: '.' + data.lang + '{.type === $type}',
                    substitution: { type: type }
                }
            }
        }

        this.data._q = {
            type: type,
            id: id,
            category: category,
            query: query,

            isOnlyOnePost: isOnlyOnePost
        };

        return apply('createSEO');
    }


    /* ---------------news------------------ */
    news: {
        var data = this.data,
            type = data.page,
            res = leJspath.findCategoryAndIdByUrl(data.req.path, type, data.lang);

        this.data._q = {
            type: type,
            id: res && res.id,
            category: res && res.category,
            query: {
                predicate: '.' + data.lang + '{.type === $type}',
                substitution: { type: type }
            }
        };

        return apply('createSEO');
    }

    authors: {
        var data = this.data,
            type = data.page,
            url = data.params.id,
            title = null,
            description = null;

        if(url){
            var source = leJspath.findByTypeAndUrl('authors', url, data.lang) ||
                         leJspath.findByTypeAndUrl('translators', url, data.lang);
            if(source) {
                title = source.firstName + ' ' + source.lastName;
                description = source.info;
            }else {
                description = title = BEM.I18N('main-menu', 'authors');
            }
        }else{
            description = title = BEM.I18N('main-menu', 'authors');
        }

        apply('setTitleAndMeta', this.ctx = { title: title, description: description });
    }

    tags: {
        var data = this.data,
            type = data.page,
            url = data.params.id,
            title = null,
            description = null;

        description = title = url || BEM.I18N('main-menu', 'tags');

        apply('setTitleAndMeta', this.ctx = { title: title, description: description });
    }

    index: {

    }

    /**
     * Мода для определения заголовка страницы и мета-информации
     * При отображении конкретного поста заголовком страницы будет название этого поста
     * В мета-информацию попадет краткое содержание (summary) и теги (tags) поста
     * Применяется для страниц:
     * - method
     * - articles
     * - news
     * - tools
     * - libs
     */
    createSEO: {
        if(!this.data._q) return {};

        var _q = this.data._q,
            title = null,
            description = null,
            keywords = null;

        this.data._m = {};

        if(_q.type) {
            description = title = BEM.I18N('main-menu', _q.type);

            if(_q.id) {
                var source = leJspath.findByIdAndType(_q.id, _q.type, this.data.lang);
                if(source) {
                    title = source.title;
                    description = source.summary;
                    keywords = source.tags ? source.tags.join(', ') : ''
                }else {
                    description = title = BEM.I18N('main-menu', _q.type);
                }
            }
        }

        apply('setTitleAndMeta', this.ctx = { title: title, description: description, keywords: keywords });

    }

    /**
     * Мода для задания заголовка страницы и мета-информации
     * Заголовок страницы хранится в поле pageTitle глобального объекта this.data
     * Вся мета-информация хранится в специальном объекте this.data._m
     */
    setTitleAndMeta: {
        this.data._m = {};

        this.data._m['ogType'] = 'article';
        this.data._m['ogUrl'] = 'http://' + this.data.req.headers.host + this.data.req.path;

        if(this.ctx.title) {
            this.data._m['ogTitle'] = this.data.pageTitle = this.ctx.title;
        }

        if(this.ctx.description) {
            this.data._m['ogDescription'] = this.data._m['description'] = this.ctx.description;
        }

        if(this.ctx.keywords) {
            this.data._m['keywords'] = this.data._m['ogKeywords'] = this.ctx.keywords;
        }
    }

    content: [
        { block : 'content' }
    ]

}
